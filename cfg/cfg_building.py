"""
This module processes all DOT format graphs of a binary to compile
them into a NetworkX graph with nodes as basic blocks
"""

import pydot

import networkx as nx
from networkx.drawing.nx_pydot import from_pydot
from networkx.relabel import convert_node_labels_to_integers

from instructions import Inst

import r2pipe

from tqdm import tqdm

import re


class CFGBuilder(object):
    """
    This class' instances manage the core functionality of this module
    """
    
    def __init__(self, sample_path: str, verbose: bool = False):
        self.func_graph_dict = {}
        self.verbose = verbose

        # open sample file and run thorough analysis
        r2 = r2pipe.open(sample_path, flags=["-e bin.cache=true"])
        _ = r2.cmd("aaa")

        # extract list of functions
        func_list = r2.cmdj('aflj')

        for func in tqdm(func_list):
            # if func["name"] != "fcn.004060e4":
            #     continue
            # go to function segment
            _ = r2.cmd(hex(func["offset"]))

            # get its CFG in DOT format
            graph_dot_str = r2.cmd("agfd")

            # process each graph and map the function name to graph
            g = convert_node_labels_to_integers(
                nx.DiGraph(from_pydot(
                    pydot.graph_from_dot_data(graph_dot_str)[0]
                ))
            )

            self.build_basic_blocks(g)

            self.func_graph_dict[func["name"]] = g

            if self.verbose:
                print(f"{func['name']} mapped to its graph")

    def build_basic_blocks(self, graph: nx.DiGraph) -> None:
        nodes_to_remove = []
        for node in graph.nodes():

            # remove nodes that are without any instructions
            try:
                insts = self.parse_node_data(graph.nodes[node]['label'])
            except (ValueError, KeyError):
                nodes_to_remove.append(node)
                continue
            graph.nodes[node].clear()

            # add instructions to the node
            graph.nodes[node]['insts'] = insts
            graph.nodes[node]['i_len'] = len(insts)

            # assure no empty nodes
            assert graph.nodes[node]['i_len'] >= 1

        graph.remove_nodes_from(nodes_to_remove)

    def parse_node_data(self, data: str) -> tuple:
        data.replace("\t", "    ")
        match1 = re.search(r"^\"0x[0-9a-zA-Z]{4,16} {6}", data)
        match2 = re.search(r"\\l0x[0-9a-zA-Z]{4,16} {6}", data)

        if match1 is None and match2 is None:
            raise ValueError("No instructions")
        elif match1 is not None:
            match = match1
        elif match2 is not None:
            match = match2
        
        # extract only instructions
        body = data[match.start():-1]

        inst_lines = []

        # match beginning of each line and get non-empty insts
        for inst_line in body.split('\\l'):
            inst_match = re.search(
                r"0x[0-9a-zA-Z]{4,16} {6}", inst_line
            )

            if inst_match is not None:
                inst_line = inst_line[inst_match.end():]

                if inst_line != '' and inst_line != '"':
                    inst_lines.append(inst_line)

        insts = []
        for inst_line in inst_lines:
            insts.append(Inst(inst_line))

        return insts
