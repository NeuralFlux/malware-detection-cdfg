"""
This module processes all DOT format graphs of a binary to compile
them into a NetworkX graph with nodes as basic blocks
"""

import pydot

import networkx as nx
from networkx.drawing.nx_pydot import from_pydot
from networkx.relabel import convert_node_labels_to_integers
from networkx.algorithms.traversal import dfs_tree
from networkx.algorithms.simple_paths import all_simple_paths

from instructions import Inst

from ordered_set import OrderedSet

from copy import deepcopy

import r2pipe

from tqdm import tqdm

import re


class CFGBuilder(object):
    """
    This class' instances manage the core functionality of this module
    """
    
    def __init__(self, sample_path: str, verbose: bool = False):
        self.func_graph_dict = {}
        self.verbose = verbose

        # open sample file and run thorough analysis
        r2 = r2pipe.open(sample_path, flags=["-e bin.cache=true"])
        _ = r2.cmd("aaa")

        # extract list of functions
        func_list = r2.cmdj('aflj')

        for func in tqdm(func_list):
            # go to function segment
            _ = r2.cmd(hex(func["offset"]))

            # get its CFG in DOT format
            graph_dot_str = r2.cmd("agfd")

            # process each graph and map the function name to graph
            g = convert_node_labels_to_integers(
                nx.DiGraph(from_pydot(
                    pydot.graph_from_dot_data(graph_dot_str)[0]
                ))
            )

            self.build_basic_blocks(g)
            ex_traces = self.get_execution_traces(g)

            self.func_graph_dict[func["name"]] = (g, ex_traces)

            if self.verbose:
                print(f"{func['name']} mapped to its graph")

    def build_basic_blocks(self, graph: nx.DiGraph) -> None:
        nodes_to_remove = []
        for node in graph.nodes():

            # remove nodes that are without any instructions
            try:
                insts = self.parse_node_data(graph.nodes[node]['label'])
            except (ValueError, KeyError):
                nodes_to_remove.append(node)
                continue
            graph.nodes[node].clear()

            # add name and instruction to the node
            graph.nodes[node]['insts'] = insts

        graph.remove_nodes_from(nodes_to_remove)

    def parse_node_data(self, data: str) -> tuple:
        data.replace("\t", "    ")
        match1 = re.search(r"^\"0x[0-9a-zA-Z]{4,16} {6}", data)
        match2 = re.search(r"\\l0x[0-9a-zA-Z]{4,16} {6}", data)

        if match1 is None and match2 is None:
            raise ValueError("No instructions")
        elif match1 is not None:
            match = match1
        elif match2 is not None:
            match = match2
        
        # extract only instructions
        body = data[match.start():-1]

        inst_lines = []

        # match beginning of each line and get non-empty insts
        for inst_line in body.split('\\l'):
            inst_match = re.search(
                r"0x[0-9a-zA-Z]{8}\s+", inst_line
            )

            if inst_match is not None:
                inst_line = inst_line[inst_match.end():]

                if inst_line != '' and inst_line != '"':
                    inst_lines.append(inst_line)

        insts = []
        for inst_line in inst_lines:
            insts.append(Inst(inst_line))

        return insts

    def get_execution_traces(self, graph: nx.DiGraph) -> list:
        """
        Get all possible execution paths in the CFG
        NOTE this function requires the edge_dfs function to return
        edges topologically
        """

        ex_traces = []

        # NOTE use OrderedSet to avoid loops
        curr_path = OrderedSet()  # maintains all nodes in one ex trace

        if len(graph.nodes()) == 0:
            return ex_traces
        source = list(graph)[0]

        if len(graph.edges()) == 0:
            curr_path.append(source)
            ex_traces.append(deepcopy(curr_path))
            return ex_traces

        # a DFS variant that finds all possible paths to leaf nodes from
        # the source
        leaves = set()
        for node in graph.nodes:
            graph.nodes[node]['colored'] = True

            colored_edges = set()
            for (_, v) in graph.out_edges(node):
                if 'colored' in graph.nodes[v].keys():
                    colored_edges.add((node, v))
            graph.remove_edges_from(colored_edges)

            if graph.in_degree(node) >= 1 and graph.out_degree(node) == 0:
                leaves.add(node)

        for leaf in leaves:
            for path in all_simple_paths(graph, source, leaf):
                ex_traces.append(deepcopy(path))
        
        return ex_traces