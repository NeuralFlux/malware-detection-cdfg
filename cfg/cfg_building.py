"""
This module processes all DOT format graphs of a binary to compile
them into a NetworkX graph with nodes as basic blocks
"""

import os
import pydot

import networkx as nx
from networkx.drawing.nx_pydot import from_pydot
from networkx.relabel import convert_node_labels_to_integers
from networkx.algorithms.traversal.edgedfs import edge_dfs

from instructions import Inst

from ordered_set import OrderedSet

from copy import deepcopy

import r2pipe

import re


class CFGBuilder(object):
    """
    This class' instances manage the core functionality of this module
    """
    
    def __init__(self, sample_path: str, verbose: bool = False):
        self.func_graph_dict = {}
        self.verbose = verbose

        # open sample file and run thorough analysis
        r2 = r2pipe.open(sample_path, flags=["-e bin.cache=true"])
        _ = r2.cmd("aaa")

        # extract list of functions
        func_list = r2.cmdj('aflj')

        for func in func_list:
            # go to function segment
            _ = r2.cmd(hex(func["offset"]))

            # get its CFG in DOT format
            graph_dot_str = r2.cmd("agfd")

            # process each graph and map the function name to graph
            g = convert_node_labels_to_integers(
                nx.DiGraph(from_pydot(
                    pydot.graph_from_dot_data(graph_dot_str)[0]
                ))
            )

            self.build_basic_blocks(g)
            ex_traces = self.get_execution_traces(g)

            self.func_graph_dict[func["name"]] = (g, ex_traces)

            if self.verbose:
                print(f"{func['name']} mapped to its graph")

    def build_basic_blocks(self, graph: nx.DiGraph) -> None:
        nodes_to_remove = []
        for node in graph.nodes():

            # remove nodes that are without any instructions
            try:
                insts = self.parse_node_data(graph.nodes[node]['label'])
            except (ValueError, KeyError):
                nodes_to_remove.append(node)
                continue
            graph.nodes[node].clear()

            # add name and instruction to the node
            graph.nodes[node]['insts'] = insts

        graph.remove_nodes_from(nodes_to_remove)

    def parse_node_data(self, data: str) -> tuple:
        match1 = re.search(r"^0x[0-9a-zA-Z]{4,16}      ", data)
        match2 = re.search(r"\\l0x[0-9a-zA-Z]{4,16}      ", data)

        if match1 is None and match2 is None:
            raise ValueError("No instructions")
        elif match1 is not None:
            match = match1
        elif match2 is not None:
            match = match2
        
        # extract only instructions
        body = data[match.start():-1]

        inst_lines = []

        # match beginning of each line and get non-empty insts
        for inst_line in body.split('\\l'):
            inst_match = re.search(
                r"0x[0-9a-zA-Z]{8}\s+", inst_line
            )

            if inst_match is not None:
                inst_line = inst_line[inst_match.end():]

                if inst_line != '' and inst_line != '"':
                    inst_lines.append(inst_line)

        insts = []
        for inst_line in inst_lines:
            insts.append(Inst(inst_line))

        return insts

    def get_execution_traces(self, graph: nx.DiGraph) -> list:
        """
        Get all possible execution paths in the CFG
        NOTE this function requires the edge_dfs function to return
        edges topologically
        """

        ex_traces = []

        # NOTE use OrderedSet to avoid loops
        curr_path = OrderedSet()  # maintains all nodes in one ex trace
        is_new_branch = False

        if len(graph.nodes()) == 0:
            return ex_traces
        source = list(graph)[0]

        if len(graph.edges()) == 0:
            curr_path.append(source)
            ex_traces.append(deepcopy(curr_path))
            return ex_traces

        for edge in edge_dfs(graph, source):

            if len(curr_path) == 0:
                # add both nodes if this is first edge
                curr_path.add(edge[0])
                curr_path.add(edge[1])

            else:
                if is_new_branch:
                    # if starting from a new branch, reset path to
                    # last branching node
                    branching_node_idx = curr_path.index(edge[0])
                    curr_path = curr_path[:branching_node_idx + 1]
                    is_new_branch = False

                # add in_edge to current path
                curr_path.append(edge[1])

            if graph.out_degree()[edge[1]] == 0:
                # if leaf node, curr_path is complete
                # and start again from previous branch in graph
                ex_traces.append(deepcopy(curr_path))
                is_new_branch = True
        
        return ex_traces