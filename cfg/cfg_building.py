"""
This module processes all DOT format graphs of a binary to compile
them into a NetworkX graph with nodes as basic blocks
"""

import os

import networkx as nx
from networkx.drawing.nx_pydot import read_dot, write_dot

from networkx.algorithms.traversal.edgedfs import edge_dfs

from instructions import Inst

from ordered_set import OrderedSet

from copy import deepcopy


class CFGBuilder(object):
    """
    This class' instances manage the core functionality of this module
    """
    
    def __init__(self, dot_files_path: str, verbose: bool = False):
        self.func_graph_dict = {}
        self.verbose = verbose
        for file in os.listdir(dot_files_path):

            # process each graph and map the function name to graph
            g = nx.DiGraph(read_dot(
                os.path.join(dot_files_path, file)
            ))
            self.build_basic_blocks(g)
            ex_traces = self.get_execution_traces(g)

            func_name = file[:-4]  # skip '.dot'
            self.func_graph_dict[func_name] = (g, ex_traces)

            if self.verbose:
                print(f"{func_name} mapped to its graph")
    
    def build_basic_blocks(self, graph: nx.DiGraph) -> None:
        nodes_to_remove = []
        for node in graph.nodes():
            assert len(graph.nodes[node].keys()) == 1  # only 'label'

            # remove nodes that are without any instructions
            try:
                name, insts = self.parse_node_data(graph.nodes[node]['label'])
            except ValueError:
                nodes_to_remove.append(node)
                continue
            graph.nodes[node].pop('label', None)

            # add name and instruction to the node
            graph.nodes[node]['name'] = name
            graph.nodes[node]['insts'] = insts

        graph.remove_nodes_from(nodes_to_remove)

    def parse_node_data(self, data: str) -> tuple:
        heading_split = data.split(':', 1)  # split only heading
        if len(heading_split) < 2:
            raise ValueError("No instructions after the heading")

        name = heading_split[0][1:]  # select heading and skip first "

        body = heading_split[1][:-1]  # skip last "
        inst_lines = [
            inst_line for inst_line in body.split('\\l')\
                if inst_line != '' and inst_line != '"'
        ]

        insts = []
        for inst_line in inst_lines:
            insts.append(Inst(inst_line))

        return name, insts

    def get_execution_traces(self, graph: nx.DiGraph) -> list:
        """
        Get all possible execution paths in the CFG
        NOTE this function requires the edge_dfs function to return
        edges topologically
        """

        ex_traces = []

        # NOTE use OrderedSet to avoid loops
        curr_path = OrderedSet()  # maintains all nodes in one ex trace
        is_new_branch = False

        for edge in edge_dfs(graph, '0'):

            if len(curr_path) == 0:
                # add both nodes if this is first edge
                curr_path.add(edge[0])
                curr_path.add(edge[1])

            else:
                if is_new_branch:
                    # if starting from a new branch, reset path to
                    # last branching node
                    branching_node_idx = curr_path.index(edge[0])
                    curr_path = curr_path[:branching_node_idx + 1]
                    is_new_branch = False

                # add in_edge to current path
                curr_path.append(edge[1])

                if graph.out_degree()[edge[1]] == 0:
                    # if leaf node, curr_path is complete
                    # and start again from previous branch in graph
                    ex_traces.append(deepcopy(curr_path))
                    is_new_branch = True
        
        return ex_traces