"""
This module processes the NetworkX graphs and their execution traces
to extract custom features for learning
"""

import os

import pandas as pd

from collections import deque

from instructions import NGram


class FeatureExtractor(object):
    """
    This class manages the core functionality of the module
    Can extract:
      - ngrams of execution traces
      - {extendable}
    """

    def __init__(self, func_graph_dict: dict, n_gram: int = 3) -> None:
        """
        Collect the execution traces and parameters for further
        processing
        """
        self.func_graph_dict = func_graph_dict
        self.n = n_gram
        self.all_ngrams = []
        assert n_gram > 1  # enforce at least bigram

        self.compile_ngrams()
    
    def extract_ngrams(self, node, graph, q):

        # add its own ngrams
        self.all_ngrams.extend(
            build_valid_ngrams(graph.nodes[node]['insts'])
        )

        # add ngrams from prev nodes
        # NOTE check 'q' + 'i_len' to save time
        if len(q) + graph.nodes[node]['i_len'] >= self.n:
            pick_max = min(graph.nodes[node]['i_len'], self.n - 1)
            self.all_ngrams.extend(
                build_valid_ngrams(
                    list(q) + graph.nodes[node]['insts'][:pick_max]
                )
            )
        
        # store this q for verifying cycle DFS later
        if 'prev_qs' not in graph.nodes[node].keys():
            graph.nodes[node]['prev_qs'] = list()
        assert q not in graph.nodes[node]['prev_qs']  # prevent space waste
        graph.nodes[node]['prev_qs'].append(q.copy())

        # then add its out_edges ngrams
        q.extend(graph.nodes[node]['insts'])
        graph.nodes[node]['visited'] = True
        for (u, v, attrs) in graph.out_edges(node, data=True):
            if 'marked' not in attrs.keys():
                graph.edges[u, v]['marked'] = True
                self.extract_ngrams(v, graph, q.copy())
            else:
                if 'prev_qs' not in graph.nodes[v].keys() \
                  or q not in graph.nodes[v]['prev_qs']:
                    self.extract_ngrams(v, graph, q.copy())

    def dfs_on_subgraphs(self, G) -> None:

        for node in G.nodes:
            for (u, v) in G.in_edges(node):
                if u != v:
                    break
            else:
                # node is a root
                q = deque(maxlen=(self.n - 1))
                self.extract_ngrams(node, G.copy(), q)


    def compile_ngrams(self) -> None:
        """
        Generate ngrams from graphs in a DFS-based approach
        that works with cycles
        """

        for _, graph in self.func_graph_dict.items():
            self.dfs_on_subgraphs(graph)


    def export_features(self,
                        curr_file: str,
                        is_malware: bool = False,
                        feat_csv_name: str = "all_features.csv"):

        if os.path.exists(feat_csv_name):
            # append
            df = pd.DataFrame({
                'file_name': [curr_file],
                'ngrams': [' '.join(map(str, self.all_ngrams))],
                'class': [int(is_malware)]  # 1 for malware
            })

            df.to_csv(feat_csv_name, index=False, header=False, mode='a')
        else:
            # create
            df = pd.DataFrame({
                'file_name': [curr_file],
                'ngrams': [' '.join(map(str, self.all_ngrams))],
                'class': [int(is_malware)]  # 1 for malware
            })

            df.to_csv(feat_csv_name, index=False)


# TODO generalise function for ngram (currently only tri-grams)
def build_valid_ngrams(inst_buffer):
    ngrams_buffer = []

    for idx in range(len(inst_buffer) - 2):
        temp_ngram = NGram([
            inst_buffer[idx],
            inst_buffer[idx + 1],
            inst_buffer[idx + 2]
        ][:])  # NOTE Copy the buffer to avoid overwriting

        if not temp_ngram.invalid_flag:
            ngrams_buffer.append(temp_ngram)

    return ngrams_buffer
