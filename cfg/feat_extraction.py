"""
This module processes the NetworkX graphs and their execution traces
to extract custom features for learning
"""

from queue import Queue

from nltk import ngrams

import os

import pickle


class FeatureExtractor(object):
    """
    This class manages the core functionality of the module
    Can extract:
      - ngrams of execution traces
      - {extendable}
    """

    def __init__(self, func_graph_dict: dict, n_gram: int = 3) -> None:
        """
        Collect the execution traces and parameters for further
        processing
        """
        self.func_graph_dict = func_graph_dict
        self.N = n_gram
        assert n_gram > 1  # enforce at least bigram

        self.build_ngrams()

    def build_ngrams(self, replace_traces: bool = True) -> None:
        """
        Generate ngrams from execution traces of graphs
        """

        for k, v in self.func_graph_dict.items():
            ngram_list = []  # one list for all traces of one graph
            for ex_path in v[1]:
                # buffer of instructions rather than loading all
                # eases memory usage
                inst_buffer = []

                idx = 0
                while idx < len(ex_path):
                    # add instructions from nodes such that they are
                    # at least N in number
                    while len(inst_buffer) < self.N:
                        node = ex_path[idx]
                        inst_buffer.extend(v[0].nodes[node]['insts'])
                        idx += 1
                    
                    # build ngrams over the instruction buffer
                    ngram_list.extend(
                        ngrams(inst_buffer, self.N)
                    )

                    # preserve last (N-1) instructions as their ngrams
                    # with upcoming instructions are pending
                    inst_buffer = inst_buffer[:][-(self.N - 1):]
            
            # OPTIONAL: replace ex trace with features
            if replace_traces:
                self.func_graph_dict[k] = (
                    self.func_graph_dict[k][0],
                    ngram_list
                )
    
    def encode_ngrams(self):
        ngrams = self.func_graph_dict['main'][1]
        self.encoded_ngrams = [0 for _ in range(len(ngrams))]

        # TODO generalise for ngram (now only trigrams)
        for idx, n_tuple in enumerate(ngrams):
            self.encoded_ngrams[idx] = \
                n_tuple[0].opcode * (1311 ** 0) + \
                n_tuple[1].opcode * (1311 ** 1) + \
                n_tuple[2].opcode * (1311 ** 2)

    def export_features(self,
                        curr_file: str = 'elf-ifelse.out',
                        feat_dict_name: str = "all_features_dict.pkl"):

        # encode each ngram tuple into a number for easier processing
        self.encode_ngrams()

        if os.path.exists(feat_dict_name):
            # append
            with open(feat_dict_name, 'rb') as in_file:
                all_features = pickle.load(in_file)

            all_features[curr_file] = self.encoded_ngrams

            with open(feat_dict_name, 'wb') as out_file:
                pickle.dump(all_features, out_file)
        else:
            # create
            all_features = {}
            all_features[curr_file] = self.encoded_ngrams

            with open(feat_dict_name, 'wb') as out_file:
                pickle.dump(all_features, out_file)
