"""
This module processes the NetworkX graphs and their execution traces
to extract custom features for learning
"""

import os

import pandas as pd

from instructions import NGram


class FeatureExtractor(object):
    """
    This class manages the core functionality of the module
    Can extract:
      - ngrams of execution traces
      - {extendable}
    """

    def __init__(self, func_graph_dict: dict, n_gram: int = 3) -> None:
        """
        Collect the execution traces and parameters for further
        processing
        """
        self.func_graph_dict = func_graph_dict
        self.n = n_gram
        self.all_ngrams = []
        assert n_gram > 1  # enforce at least bigram

        self.compile_ngrams()

    def compile_ngrams(self) -> None:
        """
        Generate ngrams from graphs
        *** # TODO Generalise to ngrams (currently only tri-grams)
        """

        for _, graph in self.func_graph_dict.items():

            # add all intra-node ngrams
            for node in graph.nodes:

                self.all_ngrams.extend(
                    build_valid_ngrams(graph.nodes[node]['insts'])
                )

            # add inter-node ngrams
            # only need (2, 1) and (1, 2) form trigrams from u, v
            # if v does not have more than 1, that case is taken care
            # when v becomes u for another edge
            for edge in graph.edges:
                (u, v) = edge
                u_insts = graph.nodes[u]['insts']
                v_insts = graph.nodes[v]['insts']

                if graph.nodes[u]['i_len'] > 1:
                    self.all_ngrams.extend(
                        build_valid_ngrams([
                            u_insts[-2:] + [v_insts[-1]]
                        ])
                    )
                    
                else:
                    # consider last inst from predecessors of u
                    for in_edge in graph.in_edges(u):
                        pos_pred = graph.nodes[in_edge[0]]['insts'][-1]

                        self.all_ngrams.extend(
                            build_valid_ngrams([
                                [pos_pred, u_insts[-1], v_insts[-1]]
                            ])
                        )

                if graph.nodes[v]['i_len'] > 1:
                    self.all_ngrams.extend(
                        build_valid_ngrams([
                            [u_insts[-1]] + v_insts[-2:]
                        ])
                    )

    def export_features(self,
                        curr_file: str,
                        is_malware: bool = False,
                        feat_csv_name: str = "all_features.csv"):

        if os.path.exists(feat_csv_name):
            # append
            df = pd.DataFrame({
                'file_name': [curr_file],
                'ngrams': [' '.join(map(str, self.all_ngrams))],
                'class': [int(is_malware)]  # 1 for malware
            })

            df.to_csv(feat_csv_name, index=False, header=False, mode='a')
        else:
            # create
            df = pd.DataFrame({
                'file_name': [curr_file],
                'ngrams': [' '.join(map(str, self.all_ngrams))],
                'class': [int(is_malware)]  # 1 for malware
            })

            df.to_csv(feat_csv_name, index=False)


# TODO generalise function for ngram (currently only tri-grams)
def build_valid_ngrams(inst_buffer):
    ngrams_buffer = []

    for idx in range(len(inst_buffer) - 2):
        temp_ngram = NGram([
            inst_buffer[idx],
            inst_buffer[idx + 1],
            inst_buffer[idx + 2]
        ][:])  # NOTE Copy the buffer to avoid overwriting

        if not temp_ngram.invalid_flag:
            ngrams_buffer.append(temp_ngram)

    return ngrams_buffer
