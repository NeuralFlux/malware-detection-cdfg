"""
This module processes all DOT format graphs of a binary to compile
them into a NetworkX graph with nodes as basic blocks
"""

import os

import networkx as nx
from networkx.drawing.nx_pydot import read_dot, write_dot
import pydot

from instructions import Inst


class CFGBuilder(object):
    """
    This class' instances manage the core functionality of this module
    """
    
    def __init__(self, dot_files_path: str):
        self.func_graph_dict = {}
        for file in os.listdir(dot_files_path):

            # process each graph and map the function name to graph
            g = nx.DiGraph(read_dot(
                os.path.join(dot_files_path, file)
            ))
            self.build_basic_blocks(g)

            func_name = file[:-4]  # skip '.dot'
            self.func_graph_dict[func_name] = g

            print(f"{func_name} mapped to its graph")
    
    def build_basic_blocks(self, graph: nx.DiGraph) -> None:
        nodes_to_remove = []
        for node in graph.nodes():
            assert len(graph.nodes[node].keys()) == 1  # only 'label'

            # remove nodes that are without any instructions
            try:
                name, insts = self.parse_node_data(graph.nodes[node]['label'])
            except ValueError:
                nodes_to_remove.append(node)
                continue
            graph.nodes[node].pop('label', None)

            # add name and instruction to the node
            graph.nodes[node]['name'] = name
            graph.nodes[node]['insts'] = insts

        graph.remove_nodes_from(nodes_to_remove)

    def parse_node_data(self, data: str) -> tuple:
        heading_split = data.split(':')
        if len(heading_split) < 2:
            raise ValueError("No instructions after the heading")

        name = heading_split[0][1:]  # select heading and skip first "

        body = heading_split[1]
        inst_strings = [
            inst_string for inst_string in body.split()\
                if inst_string != '' and inst_string != '"'
        ]

        insts = []
        for inst_string in inst_strings:
            insts.append(Inst(inst_string))

        return name, insts