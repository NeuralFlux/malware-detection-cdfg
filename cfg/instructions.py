"""
This module contains the classes required for instruction and
operand parsing
"""

from const import (
    VALID_REGS,
    INST_OPCODE_MAP,
    DEPENDENCY_COMPATIBLE_INSTS
)

import re


class NGram(object):

    # TODO generalise for n-grams (currently only for trigrams)
    def __init__(self, insts):
        self.N = len(insts)
        self.insts = tuple(insts)
        self.dependencies = [0, 0]  # dependency on inst 1
        self.invalid_flag = False

        # mark invalid if undefined inst
        for inst in self.insts:
            if inst.opcode == -1:
                self.invalid_flag = True
                break

        self.mark_dependencies()

    def mark_dependencies(self):
        # checking for 1st instruction
        if self.insts[0].write in self.insts[1].reads:
            self.dependencies[0] = 1

        # checking for 3rd instruction
        if self.insts[0].write in self.insts[2].reads and \
            self.insts[1].write in self.insts[2].reads:
            # check if 2nd inst overwrote 1st inst
            if self.insts[0].write == self.insts[1].write:
                self.dependencies[1] = 1
            else:
                self.dependencies[1] = 3

        elif self.insts[0].write in self.insts[2].reads and \
            not self.insts[1].write in self.insts[2].reads:
            self.dependencies[1] = 2

        elif not self.insts[0].write in self.insts[2].reads and \
            self.insts[1].write in self.insts[2].reads:
            self.dependencies[1] = 1

        elif not self.insts[0].write in self.insts[2].reads and \
            not self.insts[1].write in self.insts[2].reads:
            self.dependencies[1] = 0


    def __str__(self):
        inst_str = '-'.join(map(str, self.insts))
        dep_str = str(
            4 * self.dependencies[0] + self.dependencies[1]
        )

        return inst_str + '-' + dep_str


class Inst(object):

    def __init__(self, inst_line):
        self.inst = None
        self.reads = []
        self.write = None
        # split_array = inst_line.split()

        self.process_instruction_line(inst_line)
        assert self.inst is not None

        # extract the opcode
        if self.inst in INST_OPCODE_MAP.keys():
            self.opcode = INST_OPCODE_MAP[self.inst]
        else:
            self.opcode = -1

    def process_instruction_line(self, inst_line):
        temp_split_array = inst_line.split(maxsplit=1)
        self.inst = temp_split_array[0]

        if len(temp_split_array) <= 1:
            return

        op_list = temp_split_array[1]
        temp_split_array = op_list.split(', ')

        if self.inst in DEPENDENCY_COMPATIBLE_INSTS[:5]:
            # add, sub, xor, shr, shl
            # insts that read dest and src, write dest
            assert len(temp_split_array) >= 2
            dest = temp_split_array[0]
            src = None
            match = re.search("^[a-z]+", temp_split_array[1])
            if match:
                src = match.group()

            if dest in VALID_REGS:
                self.reads.append(dest)
                self.write = dest
            if src in VALID_REGS:
                self.reads.append(src)

        elif self.inst in DEPENDENCY_COMPATIBLE_INSTS[5:8]:
            # mov, movzx, lea
            # insts that read src, write dest
            assert len(temp_split_array) >= 2
            dest = temp_split_array[0]
            src = None
            match = re.search("^[a-z]+", temp_split_array[1])
            if match:
                src = match.group()

            if dest in VALID_REGS:
                self.write = dest
            if src in VALID_REGS:
                self.reads.append(src)
                # TODO add complex src for LEA using RE

        # NOTE skip IMUL because of complexity

        elif self.inst == DEPENDENCY_COMPATIBLE_INSTS[9]:
            # cmp
            # read src1, src2
            assert len(temp_split_array) >= 2
            src1 = temp_split_array[0]
            src2 = None
            match = re.search("^[a-z]+", temp_split_array[1])
            if match:
                src2 = match.group()

            if src1 in VALID_REGS:
                self.reads.append(src1)
            if src2 in VALID_REGS:
                self.reads.append(src2)

        elif self.inst in DEPENDENCY_COMPATIBLE_INSTS[10:12]:
            # push, jmp
            # read src
            assert len(temp_split_array) >= 1
            src = None
            match = re.search("^[a-z]+", temp_split_array[0])
            if match:
                src = match.group()

            if src in VALID_REGS:
                self.reads.append(src)

        elif self.inst == DEPENDENCY_COMPATIBLE_INSTS[12]:
            # pop
            # write dest
            assert len(temp_split_array) >= 1
            dest = None
            match = re.search("^[a-z]+", temp_split_array[0])
            if match:
                dest = match.group()

            if dest in VALID_REGS:
                self.write = dest

    def __str__(self):
        return self.inst

    def __eq__(self, o):
        return self.opcode == o.opcode


class Operand(object):
    pass